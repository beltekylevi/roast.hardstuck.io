<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>How Many Hours? - Valorant Time Tracker</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            val: {
              red: '#ff4655',
              dark: '#0f1923',
              darker: '#0a1118',
              card: '#1a2634',
              border: '#2a3a4a',
              text: '#eaeeb2',
            }
          }
        }
      }
    }
  </script>
  <style>
    body { background-color: #0a1118; }
    .spinner { border: 3px solid #2a3a4a; border-top-color: #ff4655; border-radius: 50%; width: 24px; height: 24px; animation: spin 0.8s linear infinite; display: inline-block; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .heatmap-cell { width: 14px; height: 14px; border-radius: 2px; }
    .tooltip { position: absolute; background: #1a2634; border: 1px solid #2a3a4a; padding: 6px 10px; border-radius: 6px; font-size: 12px; color: #ccc; pointer-events: none; z-index: 50; white-space: nowrap; }
  </style>
</head>
<body class="min-h-screen text-gray-200 font-sans">
  <div class="max-w-5xl mx-auto px-4 py-10">
    <!-- Header -->
    <div class="text-center mb-10">
      <h1 class="text-4xl font-bold mb-2">
        <span class="text-val-red">How Many Hours?</span>
      </h1>
      <p class="text-gray-400">See how much of your life Valorant has consumed</p>
    </div>

    <!-- Input -->
    <div class="flex flex-col sm:flex-row gap-3 mb-8 max-w-2xl mx-auto">
      <input
        id="usernameInput"
        type="text"
        placeholder="Player#TAG, Another#1234"
        class="flex-1 bg-val-card border border-val-border rounded-lg px-4 py-3 text-white placeholder-gray-500 focus:outline-none focus:border-val-red transition"
      />
      <button
        id="trackBtn"
        onclick="handleTrack()"
        class="bg-val-red hover:bg-red-600 text-white font-semibold px-8 py-3 rounded-lg transition active:scale-95"
      >
        Track
      </button>
    </div>

    <!-- Loading area -->
    <div id="loadingArea" class="hidden mb-8"></div>

    <!-- Results -->
    <div id="results" class="hidden">
      <!-- Period toggle -->
      <div class="flex justify-center gap-2 mb-8">
        <button onclick="setPeriod(7)" data-period="7" class="period-btn px-5 py-2 rounded-lg font-medium transition text-sm">Last 7 days</button>
        <button onclick="setPeriod(14)" data-period="14" class="period-btn px-5 py-2 rounded-lg font-medium transition text-sm">Last 14 days</button>
        <button onclick="setPeriod(30)" data-period="30" class="period-btn px-5 py-2 rounded-lg font-medium transition text-sm">Last 30 days</button>
      </div>

      <!-- Player cards -->
      <div id="playerCards" class="grid gap-6 mb-10"></div>

      <!-- Heatmap -->
      <div id="heatmapSection" class="bg-val-card border border-val-border rounded-xl p-6">
        <h2 class="text-xl font-bold mb-4 text-white">Activity Heatmap</h2>
        <div id="heatmapContainer"></div>
      </div>
    </div>

    <!-- Error -->
    <div id="errorArea" class="hidden"></div>
  </div>

  <!-- Tooltip element -->
  <div id="tooltip" class="tooltip hidden"></div>

  <script>
    let playersData = {};
    let currentPeriod = 14;

    function parseUsernames(input) {
      return input.split(',').map(s => s.trim()).filter(s => s.includes('#'));
    }

    function encodeUsername(name) {
      return encodeURIComponent(name).replace('%23', '%23');
    }

    async function fetchPlayerData(username) {
      const encoded = encodeURIComponent(username);
      const apiUrl = `https://api.tracker.gg/api/v1/valorant/matches/riot/${encoded}/aggregated?localOffset=-60&playlist=competitive&seasonId=`;
      const proxyUrl = `https://corsproxy.io/?url=${encodeURIComponent(apiUrl)}`;
      const resp = await fetch(proxyUrl);
      if (!resp.ok) throw new Error(`Failed to fetch data for ${username} (HTTP ${resp.status})`);
      const json = await resp.json();
      return json;
    }

    async function handleTrack() {
      const input = document.getElementById('usernameInput').value.trim();
      if (!input) return;

      const usernames = parseUsernames(input);
      if (usernames.length === 0) {
        showError('Please enter valid Riot IDs in the format Player#TAG');
        return;
      }

      document.getElementById('results').classList.add('hidden');
      document.getElementById('errorArea').classList.add('hidden');
      const loadingArea = document.getElementById('loadingArea');
      loadingArea.classList.remove('hidden');
      loadingArea.innerHTML = usernames.map(u =>
        `<div class="flex items-center gap-3 mb-2 text-gray-400"><div class="spinner"></div><span>Fetching ${escapeHtml(u)}...</span></div>`
      ).join('');

      document.getElementById('trackBtn').disabled = true;
      playersData = {};

      const results = await Promise.allSettled(usernames.map(async (username) => {
        const data = await fetchPlayerData(username);
        playersData[username] = data;
      }));

      document.getElementById('trackBtn').disabled = false;
      loadingArea.classList.add('hidden');

      const errors = [];
      results.forEach((r, i) => {
        if (r.status === 'rejected') errors.push(`${usernames[i]}: ${r.reason.message}`);
      });

      if (Object.keys(playersData).length === 0) {
        showError('Could not fetch data for any player. ' + errors.join('; ') +
          '<br><br>If CORS proxy is blocked, try opening this page in a different browser or disabling extensions.');
        return;
      }

      if (errors.length > 0) {
        showError('Some players failed: ' + errors.join('; '), true);
      }

      document.getElementById('results').classList.remove('hidden');
      setPeriod(currentPeriod);
    }

    function setPeriod(days) {
      currentPeriod = days;
      document.querySelectorAll('.period-btn').forEach(btn => {
        const d = parseInt(btn.dataset.period);
        if (d === days) {
          btn.classList.add('bg-val-red', 'text-white');
          btn.classList.remove('bg-val-card', 'text-gray-400', 'border', 'border-val-border');
        } else {
          btn.classList.remove('bg-val-red', 'text-white');
          btn.classList.add('bg-val-card', 'text-gray-400', 'border', 'border-val-border');
        }
      });
      renderPlayerCards();
      renderHeatmap();
    }

    function getPlayerStats(data, days) {
      const heatmap = data?.data?.heatmap || [];
      const now = new Date();
      const cutoff = new Date(now);
      cutoff.setDate(cutoff.getDate() - days);

      let totalPlaytimeMs = 0;
      let totalMatches = 0;
      let totalWins = 0;
      let totalLosses = 0;
      let daysWithData = 0;

      heatmap.forEach(entry => {
        const entryDate = new Date(entry.date);
        if (entryDate >= cutoff) {
          const playtime = entry.values?.playtime || 0;
          const matches = entry.values?.matches || 0;
          const wins = entry.values?.wins || 0;
          const losses = entry.values?.losses || 0;
          totalPlaytimeMs += playtime;
          totalMatches += matches;
          totalWins += wins;
          totalLosses += losses;
          if (playtime > 0) daysWithData++;
        }
      });

      const totalHours = totalPlaytimeMs / 1000 / 60 / 60;
      const avgHoursPerDay = totalHours / days;
      const wakingHours = days * 16;
      const totalPeriodHours = days * 24;
      const winRate = totalMatches > 0 ? (totalWins / totalMatches * 100) : 0;

      return {
        totalHours,
        avgHoursPerDay,
        totalMatches,
        totalWins,
        totalLosses,
        winRate,
        wakingPercent: (totalHours / wakingHours) * 100,
        totalPercent: (totalHours / totalPeriodHours) * 100,
        daysWithData,
        sleepHours: days * 8,
        otherHours: totalPeriodHours - totalHours - (days * 8),
      };
    }

    function renderPlayerCards() {
      const container = document.getElementById('playerCards');
      container.innerHTML = '';

      Object.entries(playersData).forEach(([username, data]) => {
        const stats = getPlayerStats(data, currentPeriod);
        const totalPeriodHours = currentPeriod * 24;
        const valPct = (stats.totalHours / totalPeriodHours * 100).toFixed(1);
        const sleepPct = (stats.sleepHours / totalPeriodHours * 100).toFixed(1);
        const otherPct = Math.max(0, 100 - parseFloat(valPct) - parseFloat(sleepPct)).toFixed(1);

        const card = document.createElement('div');
        card.className = 'bg-val-card border border-val-border rounded-xl p-6';
        card.innerHTML = `
          <h3 class="text-xl font-bold text-white mb-4">${escapeHtml(username)}</h3>
          <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-4 mb-6">
            <div>
              <div class="text-2xl font-bold text-val-red">${stats.totalHours.toFixed(1)}h</div>
              <div class="text-xs text-gray-400">Total Played</div>
            </div>
            <div>
              <div class="text-2xl font-bold text-white">${stats.avgHoursPerDay.toFixed(1)}h</div>
              <div class="text-xs text-gray-400">Avg/Day</div>
            </div>
            <div>
              <div class="text-2xl font-bold text-white">${stats.totalMatches}</div>
              <div class="text-xs text-gray-400">${stats.totalWins}W ${stats.totalLosses}L (${stats.winRate.toFixed(0)}%)</div>
            </div>
            <div>
              <div class="text-2xl font-bold text-yellow-400">${stats.wakingPercent.toFixed(1)}%</div>
              <div class="text-xs text-gray-400">Waking Hours</div>
            </div>
            <div>
              <div class="text-2xl font-bold text-gray-300">${stats.totalPercent.toFixed(1)}%</div>
              <div class="text-xs text-gray-400">Total Hours</div>
            </div>
          </div>

          <!-- Breakdown Bar -->
          <div class="mb-2 text-xs text-gray-400 font-medium">Time Breakdown</div>
          <div class="flex rounded-lg overflow-hidden h-7 mb-2">
            <div class="bg-val-red flex items-center justify-center text-xs font-medium text-white" style="width: ${Math.max(parseFloat(valPct), 0.5)}%">${parseFloat(valPct) > 3 ? valPct + '%' : ''}</div>
            <div class="bg-indigo-900 flex items-center justify-center text-xs font-medium text-indigo-200" style="width: ${sleepPct}%">${parseFloat(sleepPct) > 5 ? 'Sleep' : ''}</div>
            <div class="bg-gray-700 flex items-center justify-center text-xs font-medium text-gray-300" style="width: ${otherPct}%">${parseFloat(otherPct) > 5 ? 'Other' : ''}</div>
          </div>
          <div class="flex gap-4 text-xs text-gray-500">
            <span><span class="inline-block w-2 h-2 rounded-sm bg-val-red mr-1"></span>Valorant ${valPct}%</span>
            <span><span class="inline-block w-2 h-2 rounded-sm bg-indigo-900 mr-1"></span>Sleep ${sleepPct}%</span>
            <span><span class="inline-block w-2 h-2 rounded-sm bg-gray-700 mr-1"></span>Other ${otherPct}%</span>
          </div>
        `;
        container.appendChild(card);
      });
    }

    function renderHeatmap() {
      const container = document.getElementById('heatmapContainer');
      container.innerHTML = '';

      const allDates = new Set();
      const playerHeatmaps = {};

      Object.entries(playersData).forEach(([username, data]) => {
        const heatmap = data?.data?.heatmap || [];
        const map = {};
        heatmap.forEach(entry => {
          const dateStr = entry.date.split('T')[0];
          allDates.add(dateStr);
          map[dateStr] = {
            hours: (entry.values?.playtime || 0) / 1000 / 60 / 60,
            matches: entry.values?.matches || 0,
          };
        });
        playerHeatmaps[username] = map;
      });

      const sortedDates = [...allDates].sort();
      if (sortedDates.length === 0) {
        container.innerHTML = '<p class="text-gray-500 text-sm">No heatmap data available.</p>';
        return;
      }

      // Find max hours for color scaling
      let maxHours = 0;
      Object.values(playerHeatmaps).forEach(map => {
        Object.values(map).forEach(v => { if (v.hours > maxHours) maxHours = v.hours; });
      });
      if (maxHours === 0) maxHours = 1;

      Object.entries(playerHeatmaps).forEach(([username, map]) => {
        const row = document.createElement('div');
        row.className = 'mb-4';

        const label = document.createElement('div');
        label.className = 'text-sm text-gray-400 mb-1 font-medium';
        label.textContent = username;
        row.appendChild(label);

        const grid = document.createElement('div');
        grid.className = 'flex flex-wrap gap-[2px]';

        sortedDates.forEach(date => {
          const cell = document.createElement('div');
          cell.className = 'heatmap-cell';
          const entry = map[date];
          const hours = entry ? entry.hours : 0;
          const matches = entry ? entry.matches : 0;
          const intensity = Math.min(hours / maxHours, 1);

          if (hours === 0) {
            cell.style.backgroundColor = '#1a2634';
          } else {
            const r = Math.round(255 * 0.27 + (255 - 255 * 0.27) * intensity);
            const g = Math.round(70 * 0.27 * (1 - intensity));
            const b = Math.round(85 * 0.27 * (1 - intensity));
            cell.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
          }

          cell.addEventListener('mouseenter', (e) => {
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `<strong>${date}</strong><br>${hours.toFixed(1)}h &middot; ${matches} matches`;
            tooltip.classList.remove('hidden');
            const rect = cell.getBoundingClientRect();
            tooltip.style.left = rect.left + window.scrollX + 'px';
            tooltip.style.top = rect.top + window.scrollY - 50 + 'px';
          });
          cell.addEventListener('mouseleave', () => {
            document.getElementById('tooltip').classList.add('hidden');
          });

          grid.appendChild(cell);
        });

        row.appendChild(grid);
        container.appendChild(row);
      });
    }

    function showError(msg, isWarning = false) {
      const el = document.getElementById('errorArea');
      el.classList.remove('hidden');
      el.innerHTML = `<div class="max-w-2xl mx-auto p-4 rounded-lg ${isWarning ? 'bg-yellow-900/30 border border-yellow-700 text-yellow-300' : 'bg-red-900/30 border border-red-700 text-red-300'} text-sm">${msg}</div>`;
    }

    function escapeHtml(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    // Allow Enter key to trigger track
    document.getElementById('usernameInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') handleTrack();
    });
  </script>
</body>
</html>
